---
title: "Getting Started"
---

# Getting Started

`fuseline` is a lightweight framework for building small workflow pipelines in Python. It provides primitives for connecting tasks together and executing them synchronously or asynchronously.

## Installation

```bash
pip install fuseline
```

## Concepts

Fuseline aims to provide reusable building blocks for creating AI agents. Today the main abstraction is the **workflow**, which lets you arrange `Task` objects into a directed graph. Upcoming releases will extend this foundation with features such as **agent memory**, **agent decision making**, and **agent optimization**.

## Writing Your First Agent

### Building Steps

Steps subclass `Task` and implement `run_step` to perform work. Steps can be connected using the `>>` operator.

```python
from fuseline import Task, Workflow

class Hello(Task):
    def run_step(self, _setup_res):
        print("hello")

class World(Task):
    def run_step(self, _setup_res):
        print("world")

hello = Hello()
world = World()
hello >> world
flow = Workflow(outputs=[world])
flow.run()
```

### Typed Dependencies

Steps can depend on the output of other steps using `Depends` and `Computed`.

```python
from fuseline import Computed, Depends, Task, Workflow

class Add(Task):
    def run_step(self, x: int, y: int) -> int:
        return x + y

class Multiply(Task):
    add = Add()
    def run_step(self, value: Computed[int] = Depends(add)) -> int:
        return value * 2

mul = Multiply()
wf = Workflow(outputs=[mul])
print(wf.run({"x": 2, "y": 3}))  # prints 10
```

### Asynchronous Workflows

Use `AsyncTask` and `AsyncWorkflow` to execute steps asynchronously.

```python
import asyncio
from fuseline import AsyncTask, AsyncWorkflow

class AsyncHello(AsyncTask):
    async def run_step_async(self, _setup_res):
        await asyncio.sleep(0.1)
        print("hello")

async def main():
    step = AsyncHello()
    wf = AsyncWorkflow(outputs=[step])
    await wf.run_async()

asyncio.run(main())
```

### Parallel Execution

Run independent branches in parallel using an execution engine such as `ProcessEngine`.

```python
from fuseline import ProcessEngine

wf.run({"a": 1, "b": 2}, execution_engine=ProcessEngine(2))
```

### Exporting and Tracing

Workflows can be exported to YAML with `Workflow.export()` and execution traces can be recorded using the `trace` parameter.

```python
wf.export("workflow.yaml")
wf = Workflow(outputs=[step], trace="trace.log")
wf.run({})
```

See the example scripts in the `examples/` directory for more inspiration. The [Features](features/index.qmd) section documents additional capabilities.
